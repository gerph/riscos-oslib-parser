{#- We only really expect a single module, but if they really request multiple, we'll do it -#}

{% for defmod in defmods -%}
; CMHG file for {{ defmod.name }}
; Created from OSLib definition, {{ timestamp(now(), "%d %b %Y") }}

#include "VersionNum"
#include "riscos/Services.h"

; You should give your module a sensible name which describes its
; purpose both accurately and concisely. You must register any module
; names you use if they are to be distributed.
title-string: {{ defmod.name }}

; The help-string is the name that is displayed to the user in *Help
; Modules and other places that a more readable name is required. You
; should attempt to make this a readable version of the title-string,
; and - at worst - use the same name as in the title-string. The tail
; message may be used to indicate a variant of the module, or a
; copyright string.
help-string: {{ defmod.name }} Module_MajorVersion_CMHG Module_MinorVersion_CMHG


; The module service entry will be called to process services. You are
; strongly recommended to include the numbers of the services you wish
; to handle.
;service-call-handler:   Mod_Service Service_DCIProtocolStatus,
;                                    Service_DCIDriverStatus,
;                                    Service_InternetStatus

{%- set swis = [] -%}
{%- if defmod.swis %}
{%- set swis = defmod.modswis|dictsort()|list() %}
{%- for swi in swis -%}
  {%- if (swi[0] < 512 and not defmod.name.lower().startswith('os')) or swi[1][0].hidden -%}
    {{ swis.remove(swi) or '' }}
  {%- endif -%}
{%- endfor -%}
{# Ensure that the SWIs that are listed have gaps #}
{%- set gapped_swis = [] -%}
{%- for swi in swis -%}
  {%- set last_swinum = gapped_swis[-1][0] if (gapped_swis|length) else -1 -%}
  {%- if last_swinum != -1 and swi[0] != last_swinum + 1 -%}
    {# Need to insert a gap #}
    {%- if swi[0] - (last_swinum + 1) < 64 -%}
      {%- for n in range(swi[0] - (last_swinum + 1)) -%}
        {{ gapped_swis.append((last_swinum + 1 + n, [])) or '' }}
      {%- endfor -%}
    {%- else -%}
      ///// ERROR in processing - too many SWIs
    {%- endif -%}
  {%- endif -%}
  {{ gapped_swis.append(swi) or '' }}
{%- endfor -%}
{%- set swis = gapped_swis -%}
{%- endif -%}
{%- if swis %}
{%- set first_swi = swis[0][1] %}
{%- set swi_base = swis[0][0] %}
; If you supply SWIs in your module, you must provide a base number at
; which these start. Each chunk is 64 entries long and must be
; registered if the module is going to be distributed.
swi-chunk-base-number: &{{ '%x'|format(swi_base) }}

; The SWI decoding table lists the SWIs which the module supplies. The
; first entry is always the SWI prefix, used on all SWIs that the
; module provides. This should be the name of the module, or some
; obvious variant. You should register your SWI prefixes when you
; register a SWI chunk. Each name entry may be followed by /<entry> to
; use a particular routine to handle a SWI.
swi-decoding-table: {{ first_swi[0].name.split('_')[0] }} \
{%- for swi, swilist in swis -%}
    {%- if swilist|length %}
                    {{ swilist[0].name.split('_', 1)[1] }}/SWI_{{ swilist[0].name.split('_', 1)[1] }}
    {%- else %}
                    {{ swi - swi_base }}
    {%- endif -%}
    {{- '' if loop.last else ',' -}}
{%- endfor %}
{%- else %}
{# No SWIs defined #}
; If you supply SWIs in your module, you must provide a base number at
; which these start. Each chunk is 64 entries long and must be
; registered if the module is going to be distributed.
;swi-chunk-base-number: &12340


; The SWI decoding table lists the SWIs which the module supplies. The
; first entry is always the SWI prefix, used on all SWIs that the
; module provides. This should be the name of the module, or some
; obvious variant. You should register your SWI prefixes when you
; register a SWI chunk. Each name entry may be followed by /<entry> to
; use a particular routine to handle a SWI.
;swi-decoding-table: ModuleName \
;                    FirstSWI/SWI_FirstSWI
{%- endif %}




; If you have any error messages in your module that are returned
; through the standard interfaces, you should use different error
; numbers for each, starting at a base number. You should register your
; error bases before distributing the module. Using random error
; numbers is dangerous.
;error-base: &123400

; Allocating error messages within the module is more efficient than
; doing so manually in your C code, and is less likely to pollute error
; number space. The number is optional, and if omitted will be
; allocated from the error chunk.
;error-identifiers: err_DummyError("Dummy")


; When the module is initialised, this routine will be entered. You
; should be very careful to initialise your module safely. If anything
; fails, you can return an error message. Finalisation code will not be
; called if you return an error.
initialisation-code:    Mod_Init

; When the module is killed, this routine will be entered. If you do
; not wish to be killed then you should return an error and retain as
; much of the current state as possible. Causing an abort in this
; routine will leave a 'dead' module in the chain.
finalisation-code:      Mod_Final



; The command table is one of the more complex fields in the CMHG file. The
; first entry is the routine to call to process the commands as they arrive.
; The remainder of the entries are the command definitions. These take the
; form :
;   <Command>({<field>: <value>})
;
; Field names:
;   min-args: <number>       Minimum number of arguments to command
;   max-args: <number>       Maximum number of arguments to command
;   gstrans-map: <bits>      Bitmap of arguments that should be GSTransd
;   fs-command:              Declares that this is a filing system command
;   international:           Declares this this uses international tokens
;   add-syntax:              Adds the syntax message to the help message
;   configure:               Declares that this is a configuration name
;   status:                  Declares that this is a configuration name
;   help:                    Declares that we want to be called for help
;                            message processing. Not implemented
;   help-text: <string>      The text/token to use for *Help
;   invalid-syntax: <string> The text/token to use for syntax errors
;command-keyword-table: Mod_Command
;   Command()


{% endfor %}
