{%- macro extract_swi_name(swi) -%}
{%- if swi.name.split('_')|length > 1 -%}
{%- set parts = swi.name.split('_') -%}
{{ parts[0] }}_{{ parts[1] }}
{%- else -%}
{{ swi.name }}
{%- endif -%}
{%- endmacro -%}

{%- macro register_definition(reg) -%}
{%- if reg.assign == '?' -%}
  {{ reg.reg }} corrupted
{%- elif reg.assign == '#' -%}
  {%- if reg.name[0] == "'" -%}
    {{ reg.reg }} = {{ reg.name }} (constant word)
  {%- elif reg.name|string|length > 2 and (reg.name[0] != 'R' or reg.name[1] not in '0123456789') -%}
    {{ reg.reg }} = {{ reg.name }} (constant)
  {%- else -%}
    {{ reg.reg }} = {{ '&%x'|format(reg.name) }} (constant)
  {%- endif -%}
{%- else -%}
  {{ reg.reg }} {{ reg.assign }} {{ reg.name }} ({{reg.dtype}})
{%- endif -%}
{%- endmacro %}

{%- macro mov_constant(defmod, regnum, value) -%}
{%- if value in defmod.constants -%}
{%- set value = defmod.constants.get(value).value -%}
{%- endif -%}
{%- if value is iterable -%}
{%- set value = value[0] -%}
{%- endif -%}
{%- if value < 65536 or (value % 65536) == 0 -%}
    MOV     x{{regnum}}, #{{value}}
{%- else -%}
    MOV     x{{regnum}}, #{{ value % 65536 }}
    MOVK    x{{regnum}}, #{{ value // 65536 }}, LSL 16
{%- endif -%}
{%- endmacro -%}

{%- macro register_description(reg) -%}
{%- if reg.assign == '?' -%}
{%- elif reg.assign == '#' -%}
 corrupted
{%- elif reg.assign == '#' -%}
  {%- if reg.name[0] == "'" -%}
    {{ reg.name }} (constant word)
  {%- else -%}
    {{ reg.name }} (constant word)
  {%- endif -%}
{%- else -%}
  {{ reg.name }} ({{reg.dtype}})
{%- endif -%}
{%- endmacro -%}

{%- macro asm_regvalue_for_reg(defmod, reg, inreg) -%}
  {%- set instr = "ORR" if reg.assign == '|' else "MOV" -%}
  {%- set extra = "x" + reg.reg[1:] + ", " if reg.assign == '|' else "" -%}

  {%- if reg.assign in ('#', '|') -%}
   {%- if reg.assign != '|' or reg.name != 0 -%}
    {%- if instr == 'ORR' %}
     {%- if simple_orr_constant(defmod, reg.name) %}
    {{instr}}     {{extra}}x{{ reg.reg[1:] }}, #{{ reg.name if reg.name not in defmod.constants else defmod.constants.get(reg.name).value }}
     {%- else %}
    {{ mov_constant(defmod, '10', reg.name) }}
    {{instr}}     {{extra}}x{{ reg.reg[1:] }}, x10
     {%- endif -%}
    {%- else -%}
     {%- if reg.name[0] == "'" %}
    LDR     {{extra}}x{{ reg.reg[1:] }}, {{reg.reg[1:]}}f
     {%- else %}
    {{ mov_constant(defmod, reg.reg[1:], reg.name) }}
     {%- endif -%}
    {%- endif -%}
   {%- endif -%}
  {%- elif reg.reg[1:]|int > 7 %}
    LDR     x{{inreg}}, [x29, #16 + {{ inreg - 8 }} * 8]  // arg {{ inreg }} on caller stack
  {%- elif reg.reg[1:]|int == inreg %}
    // x{{inreg}} = {{ reg.name }}
  {%- else %}
    {{instr}}     {{extra}}x{{ reg.reg[1:] }}, x{{ inreg }}                              // {{ reg.name }}
  {%- endif -%}
{%- endmacro -%}

{%- macro asm_const_for_reg(reg, inreg) -%}
 {%- if reg.assign == '#' and reg.name[0] == "'" -%}
{{reg.reg[1:]}}:
.ascii {{ reg.name.replace("'", '"') }}
 {%- endif -%}
{%- endmacro -%}


// General macros

.altmacro
.macro signature name
0:
.asciz "\name"
.balign 4
1:
.long 0xFF000000 + ( .- 0b )
.endm


{% for defmod in defmods %}
 {%- if defmod.inctype != 'required' -%}
  {%- continue -%}
 {%- endif -%}



// ############## {{ defmod.name }} interfaces #################################

{%- macro swi_function(swi, x_variant) -%}
.section .text.{{ 'x' if x_variant else ''}}{{ oslib_swifunc(swi.defname) }}

.global {{ 'x' if x_variant else ''}}{{ oslib_swifunc(swi.defname) }}

    signature {{ 'x' if x_variant else ''}}{{ oslib_swifunc(swi.defname) }}
{{ 'x' if x_variant else ''}}{{ oslib_swifunc(swi.defname) }}:

{#- Prepare the output registers, stripping invisible elements -#}
{%- set nexitregs = (swi.outregs(x_variant)|length) -%}


{#- Register definition #}
{%- if swi.entry %}
 {%- for reg in swi.entry %}
    // {{ '=>' if loop.first else '  ' }}  {{ register_definition(reg) }}
 {%- endfor -%}
{%- endif %}
{% if swi.exit -%}
 {%- for reg in swi.exit %}
    // {{ '<=' if loop.first else '  ' }}  {{ register_definition(reg) }}
 {%- endfor %}
{%- endif %}

{#- Entry sequence #}
    STP     x29, x30, [sp, #-16]!
    MOV     x29, sp

{%- if nexitregs %}

// Prepare output registers
 {%- for outreg, reg in swi.outregs(x_variant).items()|sort %}
  {%- if outreg < 8 %}
    MOV     x{{ 15 - loop.index0 }}, x{{ outreg }}                             // output {{ reg.name }}
  {%- else %}
    // output {{ reg.name }}: arg {{ outreg }} on caller stack at offset {{ outreg - 8 }} * 8
  {%- endif %}
 {%- endfor %}
{%- endif %}

{%- if swi.entry %}

// Prepare input registers
{#- SWI input registers -#}
 {%- for inreg, regset in swi.inregs().items()|sort|reverse -%}
  {%- for reg in regset -%}
   {{ asm_regvalue_for_reg(defmod, reg, inreg) }}
  {%- endfor -%}
 {%- endfor -%}
{%- endif %}

// Call SWI
{%- set swinumber = (swi.number + ((2**17) if x_variant else 0)) %}
    {{ mov_constant(defmod, '10', swinumber) }}
    SVC     #0                                  // {{ 'X' if x_variant else '' }}{{ extract_swi_name(swi) }} ({{ '&{:x}'.format(swi.number)}})

{%- if x_variant -%}
 {%- if nexitregs %}
    CSEL    x17, xzr, x0, VC
 {%- else %}
    CSEL    x0, xzr, x0, VC
 {%- endif %}
{%- endif %}

{#- SWI output registers -#}
{%- if swi.outregs(x_variant) %}

// Store output registers
 {%- for outreg, reg in swi.outregs(x_variant).items()|sort %}
  {%- if outreg > 7 %}
    LDR     x10, [x29, #16 + {{ outreg - 8 }} * 8]             // output {{ reg.name }}
  {%- set usereg = 'x10' %}
  {%- else %}
  {%- set usereg = 'x' + ((15 - loop.index0)|string) %}
  {%- endif %}
    CBZ     {{usereg}}, x{{ oslib_swifunc(swi.defname) }}_noreg_{{outreg}}
    STR     {{ 'x' if reg.assign == '->' or dtype_width(reg.dtype) == 64 else 'w' }}{{reg.reg[1:]}}, [{{usereg}}]                           // output {{reg.name}}
{{ 'x' if x_variant else ''}}{{ oslib_swifunc(swi.defname) }}_noreg_{{outreg}}:
 {%- endfor %}
{%- endif %}
{%- if swi.returned and not x_variant and swi.returned.reg != 'FLAGS' %}
 {%- if swi.returned.reg[1:] != '0' %}
    MOV     {{ 'x' if swi.returned.assign == '->' or dtype_width(swi.returned.dtype) == 64 else 'w' }}0, {{ 'x' if swi.returned.assign == '->' or dtype_width(swi.returned.dtype) == 64 else 'w' }}{{swi.returned.reg[1:]}}                              // {{swi.returned.name}} (returned value)
 {%- else %}
    // x0 = {{swi.returned.name}} (returned value)
 {%- endif %}
{%- endif %}


{%- if nexitregs and x_variant %}

    MOV     x0, x17                             // Error pointer (or NULL)
{%- endif %}

    LDP     x29, x30, [sp], #16
    RET

{%- if swi.entry %}
 {%- for inreg, regset in swi.inregs().items()|sort|reverse -%}
  {%- for reg in regset %}
{{ asm_const_for_reg(reg, inreg) }}
  {%- endfor -%}
 {%- endfor -%}
{%- endif %}
{%- endmacro -%}

{%- for name, swi in defmod.interfaces.items()|sort if not swi.hidden %}
{{ swi_function(swi, true) }}
{{ swi_function(swi, false) }}
{% endfor %}
{% endfor %}
